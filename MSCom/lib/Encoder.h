
#ifndef MSCOM_LIB_ENCODER_H_
#define MSCOM_LIB_ENCODER_H_

/*
 *
 * Encoder.
 * Description:
 * — Objects of this class do not own data,
 * — They provide tools to write by bits into already allocated memory.
 * — Data can only be written, not read (see Decoder class to read by bits).
 * — Instances are copied in constant time.
 * — Bit counters can be reset to rewrite data.
 * — Bit counters can be rounded (see description of similar method in Decoder
 *      class).
 * — Methods used to write data are generated by templates. Those take number
 *      of bits to write as a template parameter. Compile-time check on these
 *      parameters is performed. Number of bits to write cannot be bigger than
 *      the number of bits of a type of variable that stores written data.
 * */

#include "BitView.h"

namespace msc {

    class Encoder : public BitView {
    public:
        Encoder() = default;
        Encoder(const Encoder&) = default;
        Encoder(uint8_t *, size_t);
        Encoder &operator=(const Encoder &) = default;
        ~Encoder() override = default;

        void setData(uint8_t*, size_t) noexcept;
        uint8_t *getData() const noexcept;
        bool hasData() const noexcept;

        template<size_t Bits, std::integral I>
        bool put(I val);

    private:
        void putBit(bool);

        uint8_t *data {nullptr};
    };


    // Templates Definitions

    template<size_t Bits, std::integral I>
    bool Encoder::put(I val) {
        static_assert(Bits <= sizeof(I) * 8,
                      "Decoder::get() : "
                      "try to put a number of bits that the type cannot hold."
        );
        if (bitc + Bits > dSizeBits)
            return false;
        int bits = static_cast<int>(Bits);
        while (0 < bits--) {
            putBit(val & (1 << bits));
        }
        return true;
    }

} // namespace msc

#endif //MSCOM_LIB_ENCODER_H_
